<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>$LATINA Filter</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">


  <!-- interact.js for drag/resize/rotate -->
  <script src="https://cdn.jsdelivr.net/npm/interactjs/dist/interact.min.js"></script>
  <!-- face-api.js -->
  <script src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>
  
  <!-- cute font -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Gaegu:wght@400;700&display=swap" rel="stylesheet">

  <style>
  /* ‚îÄ‚îÄ‚îÄ Variables ‚îÄ‚îÄ‚îÄ */
  :root{
    --bg: #fff9f5;
    --peach: #ffc8a2;
    --peach-dark: #e5a77c;
    --ink: #6d4c41;
    --light-peach: #ffe5d4;
    --shadow: #d7ccc8;
    --corner: 8px;
    --white: #ffffff;
    --danger: #e57373;
    --danger-dark: #c62828;
  }

  /* ‚îÄ‚îÄ‚îÄ Layout ‚îÄ‚îÄ‚îÄ */
  html,body{height:100%;margin:0}
  body{
    font-family: 'Gaegu', cursive;
    background: var(--bg) url('./assets/wallpaper.png') repeat fixed;
    color: var(--ink);
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 40px 20px;
    gap: 20px;
  }
  h2{
    margin:0;
    font-size:42px;
    font-weight: 700;
    letter-spacing:1px;
    text-shadow:1px 1px var(--white);
    color: var(--peach-dark);
  }

  /* ‚îÄ‚îÄ‚îÄ Window Frame ‚îÄ‚îÄ‚îÄ */
  .window{
    background: var(--white);
    border: 2px solid var(--ink);
    box-shadow: 4px 4px 0 var(--shadow);
    display: inline-block;
    border-radius: var(--corner);
    width: 100%;
    max-width: 600px;
    box-sizing: border-box;
  }
  .titlebar{
    height: 30px;
    background: var(--peach);
    display: flex;
    align-items: center;
    justify-content: flex-start;
    padding: 0 10px;
    border-bottom: 2px solid var(--ink);
    font-size: 20px;
    font-weight: 700;
    border-radius: 6px 6px 0 0;
  }
  .titlebar::before {
    content: 'üçë';
    margin-right: 8px;
  }

  /* ‚îÄ‚îÄ‚îÄ Content Area ‚îÄ‚îÄ‚îÄ */
  .content{padding:20px;text-align:center;}
  #image-display{
      position:relative;
      display:inline-block;
      max-width:100%;
      background: var(--light-peach);
      border: 2px dashed var(--peach-dark);
      border-radius: var(--corner);
      margin-top: 20px;
      line-height: 0;
      touch-action: none; /* Important for interact.js on the container */
  }
  #image-display canvas{
      display:block;
      max-width:100%;
      height:auto;
  }

  /* ‚îÄ‚îÄ‚îÄ Interactive Accessory Styling ‚îÄ‚îÄ‚îÄ */
  .accessory {
      position: absolute;
      user-select: none;
      box-sizing: border-box;
      transform-origin: center;
      /* Cursors for direct interaction */
      cursor: grab;
  }
  .accessory:active { cursor: grabbing; }

  .accessory.selected {
      border: 2px dashed var(--ink);
      z-index: 10;
  }
  .rotate-handle {
      display: none; /* Hidden by default */
      position: absolute;
      width: 20px;
      height: 20px;
      background: var(--white);
      border: 2px solid var(--ink);
      border-radius: 50%;
      left: 50%;
      bottom: -28px; /* Position below the selection box */
      transform: translateX(-50%);
      cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="black"><path d="M12 4c2.2 0 4.2.9 5.7 2.3l-1.4 1.4A5.99 5.99 0 0 0 12 6V4zm0 16v-2a6 6 0 0 0 4.3-1.7l1.4 1.4A7.94 7.94 0 0 1 12 20zm7.7-6.3L18.3 12A6 6 0 0 0 18 8.3l1.4-1.4c.5.8 1 1.8 1.3 2.8h-2zM4 12c0-2.2.9-4.2 2.3-5.7l1.4 1.4A5.99 5.99 0 0 0 6 12H4z"/></svg>') 16 16, auto;
  }
  .accessory.selected .rotate-handle {
      display: block; /* Visible only when selected */
  }

  /* ‚îÄ‚îÄ‚îÄ Options & Controls ‚îÄ‚îÄ‚îÄ */
  .options-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px; }
  .option-group { border: 2px solid var(--light-peach); border-radius: var(--corner); padding: 15px; text-align: left; }
  .option-group-header { display: flex; justify-content: space-between; align-items: center; border-bottom: 2px dotted var(--peach); padding-bottom: 5px; margin-bottom: 10px; }
  .option-group-header h3 { margin: 0; font-size: 22px; }
  .add-manual-btn { width: 28px; height: 28px; font-size: 24px; font-weight: bold; color: var(--ink); background-color: var(--peach); border: 2px solid var(--ink); border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center; line-height: 28px; }
  .add-manual-btn:hover { background-color: var(--peach-dark); color: var(--white); }
  .icon-options { display: flex; flex-wrap: wrap; gap: 10px; align-items: center; }
  .option-icon { width: 50px; height: 50px; border: 3px solid transparent; border-radius: var(--corner); padding: 5px; cursor: pointer; background-color: var(--bg); display: flex; align-items: center; justify-content: center; transition: all 0.2s; }
  .option-icon:hover { border-color: var(--peach); }
  .option-icon.selected { border-color: var(--peach-dark); background-color: var(--light-peach); }
  .option-icon img { max-width: 100%; max-height: 100%; object-fit: contain; }
  .option-icon.none-icon { font-size: 40px; font-weight: bold; line-height: 50px; color: var(--shadow); }
  
  /* ‚îÄ‚îÄ‚îÄ Buttons ‚îÄ‚îÄ‚îÄ */
  .controls { display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; align-items: center; margin-top: 20px; }
  button, input[type=file] { font-family: inherit; font-size: 18px; font-weight: 700; background: var(--white); border: 2px solid var(--ink); padding: 8px 16px; cursor: pointer; transition: all .2s; border-radius: 6px; box-shadow: 2px 2px 0 var(--shadow); }
  button:hover, input[type=file]:hover { transform: translate(1px, 1px); box-shadow: 1px 1px 0 var(--shadow); }
  button:active { transform: translate(2px, 2px); box-shadow: 0 0 0 var(--shadow); }
  input[type=file]::file-selector-button{ font-family:inherit; font-weight: 700; background:var(--peach); border:none; padding:4px 10px; border-radius: 4px; border-right: 2px solid var(--ink); margin-right: 10px; cursor:pointer; }
  #applyBtn { background: var(--peach-dark); color: var(--white); border-color: var(--ink); flex-grow: 1; font-size: 24px; padding: 12px 20px; }
  #applyBtn:disabled { background: var(--shadow); color: #9e9e9e; cursor: not-allowed; transform: none; box-shadow: 2px 2px 0 var(--shadow); }

  #resetBtn { background-color: var(--danger); color: white; border-color: var(--danger-dark); }
  #resetBtn:hover { background-color: #f48a8a; }

  /* ‚îÄ‚îÄ‚îÄ Status Text & Filter Checkbox ‚îÄ‚îÄ‚îÄ */
  #status{ margin-top:15px; color:var(--peach-dark); font-size:18px; height: 20px; font-weight: 700; }
  .filter-option { display: flex; align-items: center; gap: 10px; cursor: pointer; font-size: 18px; }
  input[type="checkbox"] { accent-color: var(--peach-dark); width: 18px; height: 18px; }

  @media (max-width: 640px) {
    body { padding: 20px 10px; gap: 15px; }
    h2 { font-size: 32px; text-align: center; }
    .options-grid { grid-template-columns: 1fr; }
  }
  </style>
</head>
<body>

  <h2>$LATINA Peach Studio</h2>

  <div class="window">
    <div class="titlebar"><span>LATINA Image Editor</span></div>
    <div class="content">
      
      <div class="options-grid">
        <div class="option-group">
          <div class="option-group-header"><h3>Hats</h3><div class="add-manual-btn" id="add-hat-manual" title="Add Selected Hat Manually">+</div></div>
          <div class="icon-options" id="hat-options">
            <div class="option-icon none-icon selected" data-value="none">√∏</div><div class="option-icon" data-value="beanie"><img src="./assets/beanie-nobg.png"></div><div class="option-icon" data-value="cap"><img src="./assets/cap-nobg.png"></div><div class="option-icon" data-value="sunhat"><img src="./assets/sunhat-nobg.png"></div>
          </div>
        </div>
        <div class="option-group">
          <div class="option-group-header"><h3>Glasses</h3><div class="add-manual-btn" id="add-glasses-manual" title="Add Selected Glasses Manually">+</div></div>
          <div class="icon-options" id="glasses-options">
            <div class="option-icon none-icon selected" data-value="none">√∏</div><div class="option-icon" data-value="sunglasses"><img src="./assets/sunglasses-nobg.png"></div>
          </div>
          <hr style="border: none; border-top: 2px dotted var(--peach); margin: 15px 0;">
          <label class="filter-option"><input type="checkbox" id="peach-filter"> Peach Filter</label>
        </div>
      </div>
      
      <div class="controls">
          <input type="file" id="upload" accept="image/*">
          <button id="applyBtn" disabled>‚ú® Apply Magic! ‚ú®</button>
      </div>
      <p id="status">loading models, please wait...</p>
      
      <div id="image-display" tabIndex="-1">
        <canvas id="canvas"></canvas>
      </div>

       <div class="controls">
          <button id="downloadBtn" style="display: none;">Download</button>
          <button id="resetBtn" style="display: none;">Reset</button>
       </div>

    </div>
  </div>

<script>
    const MODEL_URL = './model/';

    const uploadInput = document.getElementById('upload');
    const applyBtn = document.getElementById('applyBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const resetBtn = document.getElementById('resetBtn');
    const canvas = document.getElementById('canvas');
    const statusText = document.getElementById('status');
    const imageDisplay = document.getElementById('image-display');
    const peachFilterCheckbox = document.getElementById('peach-filter');
    const hatOptionsContainer = document.getElementById('hat-options');
    const glassesOptionsContainer = document.getElementById('glasses-options');
    const addHatManualBtn = document.getElementById('add-hat-manual');
    const addGlassesManualBtn = document.getElementById('add-glasses-manual');

    const ASSET_PATHS = { 'beanie': './assets/beanie-nobg.png', 'cap': './assets/cap-nobg.png', 'sunhat': './assets/sunhat-nobg.png', 'sunglasses': './assets/sunglasses-nobg.png', 'peach': './assets/peach.png' };
    
    let originalImage = null;
    let selectedAccessory = null;
    let coordinateScale = 1;
    const loadedAssets = {};

    async function init() {
        try {
            await Promise.all([
                faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL),
                faceapi.nets.faceLandmark68TinyNet.loadFromUri(MODEL_URL),
                ...Object.values(ASSET_PATHS).map(url => preloadImage(url))
            ]);
            statusText.textContent = 'Ready! Please upload an image.';
            setupGlobalInteractions();
        } catch (error) {
            console.error("Initialization failed:", error);
            statusText.textContent = 'Error loading. Please refresh.';
        }
    }
    
    function preloadImage(url) {
        return new Promise((resolve, reject) => {
            const img = new Image(); img.crossOrigin = "Anonymous";
            img.onload = () => { const key = Object.keys(ASSET_PATHS).find(k => ASSET_PATHS[k] === url); if (key) loadedAssets[key] = img; resolve(img); };
            img.onerror = reject; img.src = url;
        });
    }

    uploadInput.addEventListener('change', (e) => {
        const file = e.target.files[0]; if (!file) return;
        const reader = new FileReader();
        reader.onload = (event) => {
            const img = new Image();
            img.onload = () => {
                originalImage = img;
                handleReset(); // Use reset logic to clear the state
                applyBtn.disabled = false;
                statusText.textContent = 'Image loaded! Click "Apply" or add items.';
            };
            img.src = event.target.result;
        };
        reader.readAsDataURL(file);
    });

    applyBtn.addEventListener('click', applyEffects);
    downloadBtn.addEventListener('click', downloadImage);
    resetBtn.addEventListener('click', handleReset);
    addHatManualBtn.addEventListener('click', () => addAccessoryManually('hat'));
    addGlassesManualBtn.addEventListener('click', () => addAccessoryManually('glasses'));

    function handleReset() {
        if (!originalImage) return;
        clearAccessories();
        peachFilterCheckbox.checked = false;
        displayImage(originalImage);
        downloadBtn.style.display = 'none';
        resetBtn.style.display = 'none';
        statusText.textContent = 'State reset. Ready for new edits!';
    }

    function setupOptionPicker(container) {
        container.addEventListener('click', (e) => {
            const target = e.target.closest('.option-icon'); if (!target) return;
            container.querySelectorAll('.option-icon').forEach(icon => icon.classList.remove('selected'));
            target.classList.add('selected');
        });
    }
    setupOptionPicker(hatOptionsContainer);
    setupOptionPicker(glassesOptionsContainer);

    imageDisplay.addEventListener('click', (e) => {
        if (e.target.id === 'image-display' || e.target.id === 'canvas') {
            selectAccessory(null);
        }
    });
    window.addEventListener('resize', updateAccessoryPositions);

    async function applyEffects() {
        if (!originalImage) return;
        applyBtn.disabled = true; clearAccessories();
        statusText.textContent = 'Detecting face...';
        displayImage(originalImage, peachFilterCheckbox.checked);
        const detections = await faceapi.detectAllFaces(originalImage, new faceapi.TinyFaceDetectorOptions({ scoreThreshold: 0.4 })).withFaceLandmarks(true);
        if (detections.length === 0) {
            statusText.textContent = 'No face detected. Add items manually with "+".';
        } else {
            statusText.textContent = 'Face found! Placing accessories...';
            const resizedDetections = faceapi.resizeResults(detections, { width: canvas.width, height: canvas.height });
            const selectedHat = hatOptionsContainer.querySelector('.selected').dataset.value;
            const selectedGlasses = glassesOptionsContainer.querySelector('.selected').dataset.value;
            if (selectedHat !== 'none') addAccessory(selectedHat, { landmarks: resizedDetections[0].landmarks });
            if (selectedGlasses !== 'none') addAccessory(selectedGlasses, { landmarks: resizedDetections[0].landmarks });
        }
        applyBtn.disabled = false;
        showActionButtons();
    }

    function displayImage(img, applyFilter = false) {
        const ctx = canvas.getContext('2d');
        const containerWidth = imageDisplay.clientWidth || 600;
        coordinateScale = img.width / containerWidth;
        canvas.width = containerWidth;
        canvas.height = img.height / coordinateScale;
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        if(applyFilter) applyPeachFilter(ctx, canvas.width, canvas.height, false);
    }
    
    function showActionButtons() {
        downloadBtn.style.display = 'inline-block';
        resetBtn.style.display = 'inline-block';
    }

    function addAccessoryManually(category) {
        if (!originalImage) { statusText.textContent = "Please upload an image first!"; return; }
        const container = category === 'hat' ? hatOptionsContainer : glassesOptionsContainer;
        const selectedValue = container.querySelector('.selected').dataset.value;
        if(selectedValue !== 'none') { addAccessory(selectedValue); showActionButtons(); }
    }

    function addAccessory(type, options = {}) {
        const el = document.createElement('div');
        el.className = 'accessory';
        el.innerHTML = `<img src="${ASSET_PATHS[type]}" style="width:100%; height:100%; pointer-events:none;"><div class="rotate-handle"></div>`;
        
        let trueW, trueH, trueX, trueY;
        const imgAsset = loadedAssets[type];
        
        if (options.landmarks) {
            const { x, y, width, height } = calculatePlacement(type, options.landmarks);
            trueX = x * coordinateScale; trueY = y * coordinateScale; trueW = width * coordinateScale; trueH = height * coordinateScale;
        } else {
            trueW = originalImage.width / 4; trueH = (imgAsset.height / imgAsset.width) * trueW;
            trueX = (originalImage.width / 2) - (trueW / 2); trueY = (originalImage.height / 2) - (trueH / 2);
        }
        Object.assign(el.dataset, { x: trueX, y: trueY, w: trueW, h: trueH, rot: 0, asset: type });
        updateElementStyle(el);
        imageDisplay.appendChild(el);
        makeAccessoryInteractive(el);
        selectAccessory(el);
    }

    function calculatePlacement(type, landmarks) {
        if (type === 'sunglasses') {
            const leftEye = landmarks.getLeftEye(), rightEye = landmarks.getRightEye();
            const eyeCenter = { x: (leftEye[0].x + rightEye[3].x) / 2, y: (leftEye[0].y + rightEye[3].y) / 2 };
            const eyeDistance = rightEye[3].x - leftEye[0].x, width = eyeDistance * 1.8;
            return { x: eyeCenter.x - width / 2, y: eyeCenter.y - ((loadedAssets[type].height / loadedAssets[type].width) * width) / 2, width, height: (loadedAssets[type].height / loadedAssets[type].width) * width };
        } else {
            const hatScaleFactors = { 'beanie': 1.9, 'sunhat': 2.2, 'cap': 1.6 };
            const jawline = landmarks.getJawOutline(), topOfBrowY = Math.min(landmarks.getLeftEyeBrow()[0].y, landmarks.getRightEyeBrow()[0].y);
            const foreheadHeight = landmarks.getLeftEye()[0].y - topOfBrowY, topOfHeadY = topOfBrowY - (foreheadHeight * 1.5);
            const foreheadWidth = jawline[16].x - jawline[0].x, scale = hatScaleFactors[type] || 1.6, width = foreheadWidth * scale;
            return { x: (jawline[16].x + jawline[0].x) / 2 - width / 2, y: topOfHeadY - ((loadedAssets[type].height / loadedAssets[type].width) * width) * 0.9, width, height: (loadedAssets[type].height / loadedAssets[type].width) * width };
        }
    }

    function makeAccessoryInteractive(el) {
        interact(el)
            .draggable({
                listeners: { move(ev) { updatePosition(ev.target, ev.dx, ev.dy); } }
            })
            .resizable({
                edges: { left: true, right: true, top: true, bottom: true },
                listeners: {
                    move(ev) {
                        const target = ev.target;
                        let x = parseFloat(target.dataset.x) + (ev.deltaRect.left * coordinateScale);
                        let y = parseFloat(target.dataset.y) + (ev.deltaRect.top * coordinateScale);
                        Object.assign(target.dataset, { x, y, w: ev.rect.width * coordinateScale, h: ev.rect.height * coordinateScale });
                        updateElementStyle(target);
                    }
                },
                modifiers: [interact.modifiers.aspectRatio({ ratio: 'preserve' })]
            })
            .on('tap', (e) => { selectAccessory(e.currentTarget); e.preventDefault(); e.stopPropagation(); });
    }
    
    function setupGlobalInteractions() {
        // Drag anywhere on the canvas to move selected item
        interact(imageDisplay).draggable({
            allowFrom: '#canvas',
            listeners: { move(ev) { if (selectedAccessory) updatePosition(selectedAccessory, ev.dx, ev.dy); } }
        });
        // Rotation interaction for the handle
        interact('.rotate-handle').draggable({
            onmove: (event) => {
                const accessory = event.target.parentNode;
                const rect = accessory.getBoundingClientRect();
                const center = { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
                const angle = Math.atan2(center.y - event.clientY, center.x - event.clientX);
                const newRotation = angle * (180 / Math.PI) - 90;
                accessory.dataset.rot = newRotation;
                updateElementStyle(accessory);
            },
            inertia: true
        });
    }

    function updatePosition(target, dx, dy) {
        let x = parseFloat(target.dataset.x) + (dx * coordinateScale);
        let y = parseFloat(target.dataset.y) + (dy * coordinateScale);
        Object.assign(target.dataset, { x, y });
        updateElementStyle(target);
    }

    function updateElementStyle(el) {
        const { x, y, w, h, rot } = el.dataset;
        Object.assign(el.style, {
            left: `${parseFloat(x) / coordinateScale}px`, top: `${parseFloat(y) / coordinateScale}px`,
            width: `${parseFloat(w) / coordinateScale}px`, height: `${parseFloat(h) / coordinateScale}px`,
            transform: `rotate(${rot || 0}deg)`
        });
    }

    function selectAccessory(el) {
        if (selectedAccessory) { selectedAccessory.classList.remove('selected'); selectedAccessory.style.zIndex = 1; }
        selectedAccessory = el;
        if (selectedAccessory) { selectedAccessory.classList.add('selected'); selectedAccessory.style.zIndex = 10; }
    }

    function clearAccessories() {
        imageDisplay.querySelectorAll('.accessory').forEach(el => el.remove());
        selectAccessory(null);
    }
    
    function updateAccessoryPositions() {
        if (!originalImage) return;
        coordinateScale = originalImage.width / canvas.clientWidth;
        imageDisplay.querySelectorAll('.accessory').forEach(el => updateElementStyle(el));
    }

    function applyPeachFilter(ctx, width, height, isForDownload = false) {
        // Save the current state to isolate the filter effects
        ctx.save();
        
        // Use a blending mode to create a more integrated color tint
        ctx.globalCompositeOperation = 'soft-light';

        // Apply a stronger pink tint
        ctx.fillStyle = 'rgba(255, 105, 180, 0.7)'; // Hot pink at 30% opacity
        ctx.fillRect(0, 0, width, height);

        // Layer a purple tint on top for a richer color effect
        ctx.fillStyle = 'rgba(147, 112, 219, 0.65)'; // Medium purple at 25% opacity
        ctx.fillRect(0, 0, width, height);
        
        // Restore the context to its original state for drawing the peaches normally
        ctx.restore();

        // The rest of the function remains the same
        const peachImg = loadedAssets['peach']; if (!peachImg) return;
        const peachCount = isForDownload ? 30 : 15, edgeMargin = 0.15;
        for (let i = 0; i < peachCount; i++) {
            const size = (Math.random() * 0.08 + 0.05) * Math.min(width, height), angle = Math.random() * Math.PI * 2;
            let x, y;
            if (Math.random() > 0.5) { x = Math.random() * width; y = Math.random() < 0.5 ? Math.random() * height * edgeMargin : height - (Math.random() * height * edgeMargin) - size; } 
            else { y = Math.random() * height; x = Math.random() < 0.5 ? Math.random() * width * edgeMargin : width - (Math.random() * width * edgeMargin) - size; }
            ctx.save(); ctx.translate(x + size / 2, y + size / 2); ctx.rotate(angle); ctx.drawImage(peachImg, -size / 2, -size / 2, size, size); ctx.restore();
        }
    }

    function downloadImage() {
        const finalCanvas = document.createElement('canvas'); finalCanvas.width = originalImage.width; finalCanvas.height = originalImage.height;
        const ctx = finalCanvas.getContext('2d');
        ctx.drawImage(originalImage, 0, 0);
        if (peachFilterCheckbox.checked) applyPeachFilter(ctx, finalCanvas.width, finalCanvas.height, true);

        imageDisplay.querySelectorAll('.accessory').forEach(el => {
            const imgSrc = el.querySelector('img').src;
            const assetKey = Object.keys(ASSET_PATHS).find(k => imgSrc.endsWith(ASSET_PATHS[k]));
            const imgAsset = loadedAssets[el.dataset.asset]; if (!imgAsset) return;
            const { x, y, w, h, rot } = el.dataset;
            const [trueX, trueY, trueW, trueH, trueRot] = [x, y, w, h, rot].map(parseFloat);
            ctx.save(); ctx.translate(trueX + trueW / 2, trueY + trueH / 2);
            ctx.rotate(trueRot * Math.PI / 180);
            ctx.drawImage(imgAsset, -trueW / 2, -trueH / 2, trueW, trueH); ctx.restore();
        });

        const link = document.createElement('a'); link.download = 'peach-perfect.png';
        link.href = finalCanvas.toDataURL('image/png'); link.click();
    }

    init();
</script>
</body>
</html>